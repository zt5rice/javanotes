# Queue and Stack
## Basics



- Difference between average v.s. amortize time?
    - amortized time: for any specific input, we amortized all operations within this input;
    - Average time:  average of all possible inputs in the input space;
    
## Questions
### Entry

<details>1. Sort the number in two stacks (analyze from no duplication)<summary></summary>
<p>


```javascript
/*
Given an array that is initially stored in one stack, sort it with one additional stacks (total 2 stacks).

        After sorting the original stack should contain the sorted integers and from top to bottom the integers are sorted in ascending order.

        Assumptions:

        The given stack is not null.
        There can be duplicated numbers in the give stack.
        Requirements:

        No additional memory, time complexity = O(n ^ 2).
*/
import java.util.*;
public class SortWith2Stack {
    // s1: sorted stack [1--2--3
    public LinkedList<Integer> sort(LinkedList<Integer> s1) {
        LinkedList<Integer> s2 = new LinkedList<Integer>();
        // Write your solution here.
        while (!s1.isEmpty()) {
            int globalMin = Integer.MAX_VALUE;
            int count = 1; // count # Duplicates
            // step1: 找到global min 并push 到2 中
            while (!s1.isEmpty()) {
                int element = s1.pollFirst();
                if (element < globalMin) {
                    globalMin = element;
                    count = 1; //换新的 最小值了
                } else if (element == globalMin) count++;

                s2.offerFirst(element);
            }

            while (!s2.isEmpty() && s2.peekFirst() >= globalMin) //遇到== 之后 的数 出不来了
            {
                int element = s2.pollFirst();
                if (element > globalMin) {
                    s1.offerFirst(element);
                }
                // == do nothing 因为 记住了 globalMin 存哪了，和 几个
            }
            //s2 已经为空了  count==1 只有一个也要进来
            while (count >= 1) {
                s2.offerFirst(globalMin);
                count--;
            }
        }

        // 转回到 s1
        while (!s2.isEmpty()) {
            s1.offerFirst(s2.pollFirst());
        }

        return s1;
    }

    // method 2:   s1: sorted Max  | unsorted
    // sort in descending order and store i nthe bottom part of input --> eg. s1: [ 7--6--5--4-- 3 -2 in this case pop: 2 -3 -4 -5...
    public LinkedList<Integer> sort2(LinkedList<Integer> s1)
    {
        LinkedList<Integer> s2 = new LinkedList<Integer>();
        int prevMax=Integer.MAX_VALUE;
        while(s1.peekFirst()<prevMax){
            int currMax=Integer.MIN_VALUE;
            int count=0;
            while(!s1.isEmpty() && s1.peekFirst()<prevMax)
            {
                int curr = s1.pollFirst();
                if (curr>currMax)
                {
                    currMax=curr;
                    count=1;
                }
                else if (curr==currMax) count++;
                s2.offerFirst(curr);
            }
            // 先存大数字
            while (count-->=1)  // count>0？ 再--
            {
                s1.offerFirst(currMax);
            }
            //3. 添加unsorted小数
            while(!s2.isEmpty())
            {
                int temp =s2.pollFirst();
                if (currMax!=temp)  s1.offerFirst(temp);

            }
            prevMax=currMax;// 记录每次iter 上次 的currMax

        }

        return s1;
    }
}
```

</p>
</details>

<details>2. MergeSort with three Stacks (hard)<summary></summary>
<p>

```javascript
/*
1-6. Merge sort with two stacks
Reference  https://stackoverflow.com/questions/21897184/using-stacks-for-a-non-recursive-mergesort
Tested: 
Input:
[2, 5, 8, 7, 3, 4, 1, 6]
Output:
[1, 2, 3, 4, 5, 6, 7, 8]
*/
import java.util.*;
class MergeSortWithStacks {
    private int[] merge(int[] left, int[] right) {
        int[] mergearr = new int[left.length + right.length];
        int l = 0;
        int r = 0;
        int p = 0;
        while (l < left.length && r < right.length && p < mergearr.length) {
            if (left[l] <= right[r]) {
                mergearr[p++] = left[l++];
            } else {
                mergearr[p++] = right[r++];
            }
        }
        while (l < left.length && p < mergearr.length) {
            mergearr[p++] = left[l++];
        }
        while (r < right.length && p < mergearr.length) {
            mergearr[p++] = right[r++];
        }
        return mergearr;
    }
    public int[] mergeSortStacks(int[] A) {
        Stack<int[]> stack = new Stack<int[]>();
        Stack<int[]> stack2 = new Stack<int[]>();
        for (int i = 0; i < A.length; i++)
        {
            stack.push(new int[]{A[i]});
        }
        while (stack.size()>1)
        {
            while (stack.size()>1)
            {

                int[] r = stack.pop();
                int[] l = stack.pop();
                int[] merged=merge(l, r);
                stack2.push(merged);
            }
            while (stack2.size()>1)
            {

                int[] r = stack2.pop();
                int[] l = stack2.pop();
                int[] merged=merge(l, r);
                stack.push(merged);
            }
        }
        if (!stack.isEmpty() && !stack2.isEmpty()) {
            return merge(stack.pop(), stack2.pop());
        }
        return stack.isEmpty() ? stack2.pop() : stack.pop();
    }
}
```

</p>
</details>

<details><summary>3. Implement queue by two stacks: the average of all possible inputs in the input space (e.g. quicksort).</summary>
<p>


```javascript
print("hello world!")
```

</p>
</details>

### Medium
1. How to use multiple stacks to implement deque?
<details><summary>CLICK ME</summary>
<p>


```javascript
print("hello world!")
```

</p>
</details>

### Hard
1. Use three stacks to improve the time complexity of remove() operation
<details><summary>CLICK ME</summary>
<p>


```javascript
print("hello world!")
```

</p>
</details>

## Discussion and Summary
1. Properties of stack move between two stacks:
    - First transition reverse order
    - Second transition restore original order
2. What kind of question need stack? - Linear scan and look back
    a. Repeated deduplication in String;
    b. Reverse polish notation - Shunting yard algorithm;
    c. Max rectangular in Histogram;
    